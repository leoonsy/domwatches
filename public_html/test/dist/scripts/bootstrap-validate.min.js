function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

import isFunction from "lodash/isFunction";
import flatten from "lodash/flatten";
import rules from "./rules";
import feedback from "./errors";
import { SEPARATOR_OPTION, SEPARATOR_RULE, LISTENER } from "./constants";

module.exports = function (input, string, callback) {
  // Normalize the input parameter to a flat array.
  flatten([input]).forEach(function (element) {
    // Check for either element or selector.
    element = element.nodeType ? element : document.querySelector(element);
    element.addEventListener(LISTENER, function () {
      // Let's extract the rules off of the given rule argument.
      string.split(SEPARATOR_RULE).forEach(function (rule) {
        // get an array of [rule, option1, ...]
        var options = rule.split(SEPARATOR_OPTION); // Take rule name from options.

        var ruleName = options.shift(); // Take Error Text from options.

        var errorText = options.pop(); // Sometimes, we need to take special care of options.
        // Allow the use of the colon in the regex options.

        if (ruleName === "regex") {
          // Reduce the options array to its first and last element.
          options = [options.join(SEPARATOR_OPTION)];
        } // invoke the rule, returning boolean


        var validity = rules[ruleName].apply(rules, [element].concat(_toConsumableArray(options))); // DOM Manipulations to toggle errors.

        feedback(element, ruleName, validity, errorText); // optionally invoke the callback.

        if (isFunction(callback)) callback(validity);
      });
    });
  });
};

export default module.exports;
//# sourceMappingURL=bootstrap-validate.min.js.map
